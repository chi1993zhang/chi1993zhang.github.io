title: 散列表
author: Chi Zhang
tags:
  - 散列表
categories:
  - 数据结构
date: 2019-12-15 09:05:00
---
# 散列表
## 简介：
* 一种数据结构支持 INSERT，SEARCH，DELETE
* 寻址时间 O(1)
***
## 直接寻址表 (Direct-address-tables)：
#### 使用条件
* 全域U为一个比较小的集合
* 每个元素都是取自 {0,1,2 ... m - 1}
* 没有两个元素相同  
#### 表示方法
* 使用数组 T[0...m-1]
* 槽k指向关键字为k的内容
* 如果集合中没有k，T[k] = NIL
![直接寻址表](/images/pasted-1.png)
#### 操作方法
```
DIRECT-ADDRESS-SEARCH(T,k) # O(1)
	return T[k];
DIRECT-ADDRESS-INSERT(T,k) # O(1)
	T[x,key] = x;
DIRECT-ADDRESS-DELETE(T,k) # O(1)
	T[x,key] = NIL;
```
***
## 散列表 (Hash-Table)
#### 优点
* 当U为一个很大集合且实际关键字K集合较小时空间使用相比直接寻址表大大缩小
#### 缺点
* 平均时间为O(1)而直接寻址表最差为O(1)
* 可能产生冲突
#### 实现方法
* 使用散列函数将key映射到槽中
![散列表](/images/pasted-2.png)
#### 冲突避免方法
##### 链接法
###### 实现方法
```
CHAIN-HASH-INSERT(T,x) # O(1)
	insert x at head of list T[h(x,key)]
CHAIN-HASH-SEARCH(T,x) 
# O(1 + α) α 装载因子 n / m （n个元素，m个槽位）
	search for an element with key k in list T[h(x,key)]
CHAIN-HASH-DELETE(T,x) # O(1) 双向链表
# exp. ListNode *x. x->prev->next = x->next
	delete x from the list T[h(x,key)]
```
![链接法](/images/pasted-3.png)
##### 开发寻址法
###### 实现方法
```
HASH-INSERT(T, k)
	i=0
    repeat
    j=h(k,i)
    	if T[j]==NIL
        	T[j]=k
            return j
        else i=i+1
    until i==m 
    error "hash table overflow"
HASH-SEARCH(T,k)
	i=0
    repeat
    j=h(k,j)
    	if T[j]==k
        	return j
        i=i+1
    until T[j]==NIL or i==m
    return NIL
HASH-DELETE(T,k)
	Mark as DELETED
```
###### 寻址方法
* 线性探测
当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。
![线性探测](/images/v2-56d43d5e9805d47e034ae90ef619a49a_hd.webp)
当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。以上图为例，散列表的大小为 8 ，黄色区域表示空闲位置，橙色区域表示已经存储了数据。目前散列表中已经存储了 4 个元素。此时元素 7777777  经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了，所以就产生了冲突。于是按顺序地往后一个一个找，看有没有空闲的位置，此时，运气很好正巧在下一个位置就有空闲位置，将其插入，完成了数据存储。线性探测法一个很大的弊端就是当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，需要从头到尾探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。
* 二次探测
二次探测是二次方探测法的简称。顾名思义，使用二次探测进行探测的步长变成了原来的“二次方”，也就是说，它探测的下标序列为 hash(key)+0，hash(key)+1^2或[hash(key)-1^2]，hash(key)+2^2或[hash(key)-2^2]。
![二次探测](/images/v2-45dd2f2509424a5d7be945acd4e6bd7e_hd.webp)
以上图为例，散列表的大小为 8 ，黄色区域表示空闲位置，橙色区域表示已经存储了数据。目前散列表中已经存储了 7 个元素。此时元素 7777777  经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了，所以就产生了冲突。按照二次探测方法的操作，有冲突就先 + 1^2，8 这个位置有值，冲突；变为 - 1^2，6 这个位置有值，还是有冲突；于是 - 2^2， 3 这个位置是空闲的，插入。
* 双重散列
所谓双重散列，意思就是不仅要使用一个散列函数，而是使用一组散列函数 hash1(key)，hash2(key)，hash3(key)。。。。。。先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。
![双重散列](/images/v2-0adbdf4c6735aedf6c0e992831d38a65_hd.webp)
以上图为例，散列表的大小为 8 ，黄色区域表示空闲位置，橙色区域表示已经存储了数据。目前散列表中已经存储了 7 个元素。此时元素 7777777  经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了，所以就产生了冲突。此时，再将数据进行一次哈希算法处理，经过另外的 Hash 算法之后，被散列到位置下标为 3 的位置，完成操作。事实上，不管采用哪种探测方法，只要当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，需要尽可能保证散列表中有一定比例的空闲槽位。一般使用加载因子（load factor）来表示空位的多少。加载因子是表示 Hsah 表中元素的填满的程度，若加载因子越大，则填满的元素越多,这样的好处是：空间利用率高了,但冲突的机会加大了。反之,加载因子越小,填满的元素越少,好处是冲突的机会减小了，但空间浪费多了。
***
## 散列函数
#### 好的散列函数
* 每个x都被等可能的散列到m个槽位中的任意一个
* 与其他关键字散列到哪个槽位无关
#### 简单的散列函数
* 除法散列
* 乘法散列
***

## 参考
《算法导论》
https://www.zhihu.com/question/47258682/answer/572450659